Объект — тип данных, который хранит в себе информацию в виде пар «ключ-значение». Каждый элемент сопоставлен со своим ключом и порядок элементов совсем неважен.

Передача по ссылке
Объект всегда один, в памяти не создаётся новое место под копию объекта. Каждая переменная содержит не новую отдельную сущность, а ссылку на один-единственный объект. Поэтому когда мы меняем что-то в объекте через одну из переменных, в которой содержится ссылка на него, изменения видны во всех других переменных, будь их хоть двадцать или сорок. Это важная особенность объектов, которую надо запомнить. Она так и называется — передача объектов по ссылке.

var firstCat = {
  name: 'Кекс',
  age: 5
};

var secondCat = firstCat;
console.log(secondCat);
// Выведет: {name:"Кекс", age:5}

firstCat.name = 'Снежок';
console.log(secondCat);
// Выведет: {name:"Снежок", age:5}

Объект как словарь
Теперь посчитаем цену компьютера. Она состоит из нескольких слагаемых: стартовой цены и стоимости каждой технической характеристики. Расценки:

Процессор 'i5'	5000
Процессор 'i7'	10000
Дисплей 13 дюймов	5000
Дисплей 15 дюймов	10000
Оперативная память 8 Гб	3000
Оперативная память 16 Гб	7000
Выходит, нам нужно проверять значения свойств в объекте компьютера и, в зависимости от результата, прибавлять к базовой цене ту или иную сумму. В итоге мы получим цену устройства. Для проверки каждой характеристики отдельно можно использовать конструкцию else if. Тогда код будет выглядеть примерно так:

var price = computer.basicPrice;

if (computer.processor === 'i5') {
  price += 5000;
} else if (computer.processor === 'i7') {
  price += 10000;
}

// И так далее суммируем стоимость остальных компонентов
Код рабочий, но не кажется ли он слишком большим? Сейчас у нас только три характеристики, из которых складывается цена устройства, а что, если их станет больше?

В некоторых ситуациях блоки с условиями можно сократить с помощью объектов. Давайте разбираться, как это сделать. Рассмотрим на примере.

var printFavoriteFood = function (name) {
  var message = 'Моя любимая еда — ';

  if (name === 'Кекс') {
    message += 'рыба';
  } else if (name === 'Рудольф') {
    message += 'котлета';
  } else if (name === 'Снежок') {
    message += 'сметана';
  }

  return message;
};

console.log(printFavoriteFood('Снежок')); // Выведет: Моя любимая еда — сметана
Обратите внимание, что каждому коту, а точнее его имени, соответствует определённая еда. При этом порядок котов совсем неважен. Можно ли записать вкусовые предпочтения котов в объект? Давайте попробуем.

var catsFavoriteFood = {
  Кекс: 'рыба',
  Рудольф: 'котлета',
  Снежок: 'сметана'
};
Можно ли теперь использовать данные в объекте catsFavoriteFood так, чтобы совсем избавиться от условий в теле функции printFavoriteFood? Можно! Перед нами обычный объект со свойствами и их значениями. Значит, мы можем обратиться к свойству объекта и подставить в выражение строку, которая в нём содержится.

var catsFavoriteFood = {
  Кекс: 'рыба',
  Рудольф: 'котлета',
  Снежок: 'сметана'
};

var printFavoriteFood = function (name) {
  return 'Моя любимая еда — ' + catsFavoriteFood[name];
};

console.log(printFavoriteFood('Снежок')); // Выведет: Моя любимая еда — сметана
Код работает, как и прежде, зато насколько сократилась наша программа!

Мы записали в объект не характеристику вида name: 'Кекс', а соотношение имени кота и лакомства, которое по вкусу именно ему. Такие объекты называют словарями, мапами или ассоциативными массивами. Они очень удобны в использовании и позволяют писать код чище и проще.

В нашей программе для каждого показателя подходит своя цена, например, для процессора 'i7' это 10000, для дисплея 13 дюймов это 5000. Значит, мы можем сделать словари, которые будут хранить стоимость каждой характеристики, а затем обращаться к свойствам этих объектов, чтобы получить цену.

---------------------------------------------------------

Не будем вырывать из контекста
Наша программа готова! Вся необходимая функциональность написана! Осталось обсудить ещё один вопрос.

Внутри методов мы обращаемся к свойствам объекта компьютера computer.свойство. А что, если в будущем название объекта изменится и количество свойств увеличится? Придётся везде исправлять computer на что-то новое. Лень — одно из главных качеств разработчика, переписывать названия совсем не хочется. Хорошо, что есть ключевое слово this. Им-то мы и воспользуемся.

this недаром называется именно так. Если в речи такое местоимение указывает на определённый предмет, то в JavaScript ключевое слово this указывает на конкретный объект, а именно на тот объект, на котором была вызвана функция (метод).

Использовать this просто, достаточно заменить название объекта на ключевое слово в обращении к свойству. Вместо объект.свойство используем this.свойство.

var cat = {
  name: 'Рудольф',

  introduce: function () {
    console.log('Мяу! Я кот ' + this.name + '!');
  }
};

cat.introduce(); // Выведет: Мяу! Я кот Рудольф!
Объект, на который указывает this называется контекстом вызова.

Важная деталь: пока функция не вызвана, this не содержит никакого значения, контекст появляется только в момент вызова функции.

Ключевое слово this приносит много пользы разработчикам. О других преимуществах и особенностях this вы узнаете позже, в дальнейших курсах, а пока заменим обращение к свойствам внутри объекта computer.

-------------------------------------------------------------------

