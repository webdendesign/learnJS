// Б20. Все файлы JS представляют собой отдельные модули в IIFE
// Экспорт значений производится через глобальную область видимости.
//  Код вне модуля запрещён. Вне модуля могут располагаться комментарии и утилитные инструкции,
//   такие как 'use strict';

// Пример правильного модуля:

"use strict";

(function() {
  window.load = function(url, onLoad) {
    var xhr = new XMLHttpRequest();
    xhr.addEventListener("load", onLoad);

    xhr.responseType = "json";
    xhr.open("GET", url);
    xhr.send();
  };
})();

// Б21. Все значения, используемые только внутри модулей ограничены по видимости
// Из модуля ничего не должно попадать случайными образом в глобальную область видимости

// Неправильно:

("use strict");

var ENTER_KEYCODE = 13;

(function() {
  var userIcon = document.querySelector(".user");

  userIcon.addEventListener("keydown", function(evt) {
    if (evt.keyCode === ENTER_KEYCODE) {
      popup.classList.remove("hidden");
    }
  });
})();

// Правильно:

("use strict");

(function() {
  var ENTER_KEYCODE = 13;

  var userIcon = document.querySelector(".user");

  userIcon.addEventListener("keydown", function(evt) {
    if (evt.keyCode === ENTER_KEYCODE) {
      popup.classList.remove("hidden");
    }
  });
})();

// Б22. Код является кроссбраузерным и не вызывает ошибок в разных браузерах и разных операционных системах
// При проверке этого критерия, необходимо удостовериться в правильной работе и отсутствии сообщений об ошибках в выполняемых скриптах только в последних версиях браузеров: Chrome, Firefox, Safari, Microsoft Edge.

// Б23. Нельзя пользоваться глобальной переменной event
// Приводит к неосознанному коду:

var elem = document.querySelector(".test");

var onElemClick = function() {
  event.target.innerText = "you really need event";
};

elem.addEventListener("click", oneElemClick);

// Б24. Своевременный выход из цикла: цикл не работает дольше чем нужно
// Неправильно:

apartments.forEach(function(it, index) {
  if (index < 3) {
    render(it);
  }
});

// Правильно:

for (var i = 0; i < Math.min(apartments.length, 3); i++) {
  render(apartments[i]);
}

// Б25. Количество вызовов циклов минимизировано
// Если задачу можно решить за один проход по циклу, вместо нескольких она должна быть решена за один

// Неправильно:

var wizardNames = source.map(function (it) {
  return it.wizard;
}).map(function (it) {
  return it.name;
});

// Правильно:

var wizardNames = source.map(function (it) {
  return it.wizard.name;
});

// Б26. Множественные DOM-операции производятся на элементах, которые не добавлены в DOM
// Например, наполнение скопированного из шаблона элемента данными

// Б27. Обработчики события добавляются и удаляются своевременно
// Обработчики событий для виджетов добавляются только в момент появления виджета на странице и удаляются в момент их исчезновения.

// Защита от memory-leak
// Кол-во обработчиков подвешенных на глобальную область видимости не должно возрастать. Например, если подвешивается обработчик, который следит за перемещением курсора по экрану, то он должен подвешиваться и отвешиваться в нужный момент. В случае если обработчик на document только подвешивается это может свидетельствовать о проблеме бесконечного создания обработчиков и потенциальной утечке памяти.

// Защита от неправильного поведения интерфейса Например, на странице может существовать попап, который скрывается по ESC. Лучше для него гасить обработчик, если он не показан, потому что он может каким-то образом ломать поведение сайта — останавливать распространение, отменять поведение по умолчанию и т.д. Поэтому поведение должно быть явным — если в этот момент времени обработчики не нужны, их нужно удалить. Явное и предсказуемое поведение.

// Б28. Для вставки пользовательских строк (имён, фамилий и т.д.) использован textContent
// Защита от XSS-атак, а также изменения исходных данных, запутывание пользователя и прочее

// Неправильно: через innerHTML вставляются данные, которые невозможно полностью контролировать. Это может быть пользовательский ввод, который может содержать XSS.

var listItem = listItemTemplate.cloneNode(true);
listItem.querySelector('.title').innerHTML = user.fullName;

// Правильно: через innerHTML вставляется код, который был создан программистом, поэтому сделать его вредоносным невозможно. innerHTML используется для лаконичного создания сложной разметки, но при этом в разметку не вставляются никакие внешние данные.

var listItemTemplate = '<li class="amenity><i></i><a href="#"></a></li>';
list.innerHTML = listItemTemplate;